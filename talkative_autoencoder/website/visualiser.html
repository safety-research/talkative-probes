<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Log Data Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #F9F5F0; /* Warm, browny-beige */
            color: #5D4037; /* Rich brown text */
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #EFEBE9; }
        ::-webkit-scrollbar-thumb { background: #D7CCC8; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #BCAAA4; }
        
        /* Copy feedback tooltip */
        .copy-feedback {
            position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%);
            background-color: #3E2723; color: white; padding: 4px 8px;
            border-radius: 4px; font-size: 12px; opacity: 0;
            transition: opacity 0.3s, transform 0.3s; pointer-events: none;
        }
        .copy-feedback.show { opacity: 1; transform: translateX(-50%) translateY(-5px); }
        
        .token-box-container {
            display: inline-block;
            position: relative;
            vertical-align: bottom;
            border: 1px solid #D7CCC8;
            background-color: white;
            padding: 2px 6px;
            margin: 2px;
            border-radius: 4px;
        }

        .token-box {
            line-height: 1.5;
        }
        
        .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-8px);
            background-color: #3E2723;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-family: 'Inter', sans-serif;
            white-space: pre-wrap;
            word-break: break-word;
            width: max-content; 
            max-width: 300px;
            z-index: 20;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.2s, visibility 0.2s;
        }

        .token-box-container:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }
        
        .transpose-col {
            /* No special styles needed */
        }

        .rotated-token-wrapper {
            position: relative;
            height: 120px; /* Reserves space for the rotated token */
            width: 100%;
        }

        .rotated-token {
            position: absolute;
            bottom: 10px; /* Position up from the wrapper's bottom */
            left: 0; /* Align to the left */
            transform: rotate(-15deg) translate(3px,0); /* anticlockwise rotation */
            transform-origin: bottom left; /* Pivot from the bottom-left corner */
            white-space: nowrap;
            font-size: 0.8rem;
            z-index: 10;
        }
        
        .explanation-word {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .primary-btn {
            background-color: #E65100; color: white;
            font-weight: 600; border-radius: 0.5rem;
            transition: all 0.2s;
        }
        .primary-btn:hover { background-color: #BF360C; }
        
        .secondary-btn {
             background-color: white; border: 1px solid #D7CCC8; color: #5D4037;
             font-weight: 600; border-radius: 0.5rem;
             transition: all 0.2s;
        }
        .secondary-btn:hover { border-color: #BCAAA4; background-color: #F5F5F5; }
        .secondary-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .resize-handle {
            position: absolute;
            top: 0;
            right: -4px;
            width: 8px;
            height: 100%;
            cursor: col-resize;
            z-index: 10;
        }
        
        #output-table th {
            position: relative;
        }

        .settings-input {
            border: 1px solid #D7CCC8;
            border-radius: 0.5rem;
            padding: 4px 8px;
            width: 300px;
        }

        .service-btn {
            padding: 8px 12px;
            border: 1px solid #D7CCC8;
            background-color: white;
            color: #5D4037;
            cursor: pointer;
            transition: all 0.2s;
            flex-grow: 1;
        }
        .service-btn:first-child {
            border-top-left-radius: 0.375rem;
            border-bottom-left-radius: 0.375rem;
        }
        .service-btn:last-child {
            border-top-right-radius: 0.375rem;
            border-bottom-right-radius: 0.375rem;
            border-left-width: 0;
        }
        .service-btn.active-service {
            background-color: #A1887F;
            color: white;
            border-color: #A1887F;
            font-weight: 600;
        }
        .service-btn:not(.active-service):hover {
            background-color: #F5F5F5;
        }

    </style>
</head>
<body class="antialiased">

    <div class="container mx-auto">
        <div class="p-4 sm:p-6 md:p-8">
            <div class="mb-6 p-4 bg-amber-50 border border-amber-200 rounded-lg">
                <details>
                    <summary class="cursor-pointer font-semibold text-[#5D4037]">Settings for Sharing</summary>
                    <div class="mt-4 space-y-4">
                        <div>
                            <label class="block font-medium text-sm text-[#5D4037]">Storage Service:</label>
                            <div id="service-switcher" class="mt-1 flex rounded-md shadow-sm" style="width: 300px;">
                               <button id="pantry-btn" class="service-btn">Pantry</button>
                               <button id="jsonbin-btn" class="service-btn">JSONBin.io</button>
                            </div>
                        </div>
                        <div>
                            <label for="api-key-input" class="block font-medium text-sm text-[#5D4037]">Your Public, Scoped API Key:</label>
                            <input type="text" id="api-key-input" class="mt-1 settings-input" placeholder="Paste your public API key here">
                        </div>
                         <div>
                            <label for="collection-id-input" class="block font-medium text-sm text-[#5D4037]">Your Public Collection ID:</label>
                            <input type="text" id="collection-id-input" class="mt-1 settings-input" placeholder="Paste your public Collection ID here">
                        </div>
                        <p class="mt-2 text-xs text-amber-800">To allow anyone to upload, you must provide a public, write-only API key and the ID of the Collection it belongs to. See instructions on your GitHub Pages site for how to create these.</p>
                    </div>
                </details>
            </div>

            <div class="mb-8">
                <h2 class="text-2xl font-semibold mb-4 text-[#5D4037]">Input Data</h2>
                <div class="bg-white rounded-lg border border-slate-200 shadow-sm">
                    <textarea id="text-input" class="w-full h-48 p-4 bg-transparent text-[#5D4037] border-none rounded-lg focus:ring-0 resize-y" placeholder="Paste one or more JSON objects..."></textarea>
                </div>
                <div class="mt-4 flex flex-wrap items-center justify-start gap-4">
                    <button id="parse-btn" class="flex items-center justify-center gap-2 px-5 py-2 primary-btn shadow-sm transform hover:scale-105">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/><path d="m12 12-2 2 2 2"/><path d="m19 12-2 2 2 2"/></svg>
                        Visualize
                    </button>
                    <button id="upload-btn" class="flex items-center justify-center gap-2 px-5 py-2 secondary-btn shadow-sm transform hover:scale-105" disabled>
                         <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></svg>
                        Upload & Get Link
                    </button>
                    <label for="file-upload" class="cursor-pointer flex items-center justify-center gap-2 px-5 py-2 secondary-btn shadow-sm transform hover:scale-105">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 22h14a2 2 0 0 0 2-2V7.5L14.5 2H6a2 2 0 0 0-2 2v4"/><polyline points="14 2 14 8 20 8"/><path d="M2 15h10"/><path d="m5 12-3 3 3 3"/></svg>
                        Load from File
                    </label>
                    <input id="file-upload" type="file" class="hidden" accept=".json,.txt,application/json">
                </div>
                <div id="controls-separator" class="my-4 border-b border-slate-200 hidden"></div>
                 <div id="navigation-container" class="mt-4 flex items-center justify-center gap-4 hidden">
                    <button id="prev-btn" class="px-4 py-2 secondary-btn shadow-sm">&lt; Prev</button>
                    <span id="nav-counter" class="font-semibold text-[#5D4037]"></span>
                    <button id="next-btn" class="px-4 py-2 secondary-btn shadow-sm">Next &gt;</button>
                </div>
                <div id="display-controls" class="mt-4 flex-wrap items-center gap-x-8 gap-y-4 hidden">
                     <div id="column-toggle-container" class="flex items-center gap-4"></div>
                     <button id="transpose-btn" class="flex items-center justify-center gap-2 px-5 py-2 secondary-btn shadow-sm transform hover:scale-105">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
                        Transpose
                    </button>
                     <div id="line-spacing-control" class="flex items-center gap-4">
                        <label for="line-spacing-slider" class="font-semibold text-[#5D4037]">Line Spacing:</label>
                        <input id="line-spacing-slider" type="range" min="0" max="10" value="0" class="w-48">
                    </div>
                    <div id="col-width-control" class="flex items-center gap-4 hidden">
                        <label for="col-width-slider" class="font-semibold text-[#5D4037]">Column Width:</label>
                        <input id="col-width-slider" type="range" min="80" max="400" value="80" class="w-48">
                    </div>
                    <div id="salience-control" class="flex items-center gap-2">
                        <input type="checkbox" id="salience-toggle" class="h-4 w-4 rounded border-slate-300 text-orange-600 focus:ring-orange-500">
                        <label for="salience-toggle" class="font-semibold text-[#5D4037]">Color by Salience</label>
                    </div>
                    <!-- Colour scale bar (hidden until salience colouring is enabled) -->
                    <div id="salience-colorbar" class="h-2 w-56 rounded hidden" title="Salience scale"></div>
                    <p id="salience-definition" class="text-xs text-[#5D4037] mt-1 hidden">Salience = % increase in MSE when the decoded token is replaced with a space token ` `. Higher (red) ⇒ more important.</p>
                </div>
            </div>
            
            <div id="metadata-display" class="my-4 p-4 bg-amber-50 border border-amber-200 rounded-lg hidden text-sm text-[#5D4037]"></div>

            <div class="mb-8">
                <h2 class="text-2xl font-semibold mb-4 text-[#5D4037]">Full Text</h2>
                <div id="full-text-container" class="p-4 bg-white rounded-lg border border-slate-200 shadow-sm leading-relaxed">
                     <p id="full-text-placeholder" class="text-slate-500">Full text will appear here after visualizing.</p>
                </div>
            </div>

            <div id="output-container">
                 <h2 class="text-2xl font-semibold my-4 text-[#5D4037]">Visualization</h2>
                 <div id="output-container-wrapper" class="relative">
                    <button id="side-prev-btn" class="absolute left-0 top-0 h-full w-6 bg-transparent hover:bg-slate-200/50 z-20 transition-colors cursor-pointer border-none p-0 hidden group flex items-center justify-center rounded-l-lg">
                        <svg class="w-5 h-5 text-slate-500 opacity-0 group-hover:opacity-100 transition-opacity" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
                    </button>
                    <div id="output-inner-wrapper" class="overflow-x-auto w-full">
                        <p id="output-placeholder" class="text-slate-500 text-center mt-16">Your parsed data will appear here.</p>
                        <table id="output-table" class="min-w-full hidden">
                            <thead id="table-head"></thead>
                            <tbody id="table-body"></tbody>
                        </table>
                        <div id="transposed-view" class="hidden"></div>
                    </div>
                    <button id="side-next-btn" class="absolute right-0 top-0 h-full w-6 bg-transparent hover:bg-slate-200/50 z-20 transition-colors cursor-pointer border-none p-0 hidden group flex items-center justify-center rounded-r-lg">
                        <svg class="w-5 h-5 text-slate-500 opacity-0 group-hover:opacity-100 transition-opacity" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                    </button>
                </div>
            </div>
            
            <div id="bottom-navigation-container" class="mt-8 flex items-center justify-center gap-4 hidden">
                <button id="bottom-prev-btn" class="px-4 py-2 secondary-btn shadow-sm">&lt; Prev</button>
                <span id="bottom-nav-counter" class="font-semibold text-[#5D4037]"></span>
                <button id="bottom-next-btn" class="px-4 py-2 secondary-btn shadow-sm">Next &gt;</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const textInput = document.getElementById('text-input');
            const parseBtn = document.getElementById('parse-btn');
            const fileUpload = document.getElementById('file-upload');
            const tableHead = document.getElementById('table-head');
            const tableBody = document.getElementById('table-body');
            const outputTable = document.getElementById('output-table');
            const outputPlaceholder = document.getElementById('output-placeholder');
            const columnToggleContainer = document.getElementById('column-toggle-container');
            const fullTextContainer = document.getElementById('full-text-container');
            const fullTextPlaceholder = document.getElementById('full-text-placeholder');
            const transposeBtn = document.getElementById('transpose-btn');
            const transposedView = document.getElementById('transposed-view');
            const navigationContainer = document.getElementById('navigation-container');
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const navCounter = document.getElementById('nav-counter');
            const displayControls = document.getElementById('display-controls');
            const colWidthControl = document.getElementById('col-width-control');
            const colWidthSlider = document.getElementById('col-width-slider');
            const lineSpacingSlider = document.getElementById('line-spacing-slider');
            const uploadBtn = document.getElementById('upload-btn');
            const apiKeyInput = document.getElementById('api-key-input');
            const collectionIdInput = document.getElementById('collection-id-input');
            const controlsSeparator = document.getElementById('controls-separator');
            const pantryBtn = document.getElementById('pantry-btn');
            const jsonbinBtn = document.getElementById('jsonbin-btn');
            const apiKeyLabel = document.querySelector('label[for="api-key-input"]');
            const collectionIdLabel = document.querySelector('label[for="collection-id-input"]');
            const metadataDisplay = document.getElementById('metadata-display');
            const salienceToggle = document.getElementById('salience-toggle');
            const salienceColorbar = document.getElementById('salience-colorbar');
            const salienceDefinition = document.getElementById('salience-definition');
            const bottomNavigationContainer = document.getElementById('bottom-navigation-container');
            const bottomPrevBtn = document.getElementById('bottom-prev-btn');
            const bottomNextBtn = document.getElementById('bottom-next-btn');
            const bottomNavCounter = document.getElementById('bottom-nav-counter');
            const sidePrevBtn = document.getElementById('side-prev-btn');
            const sideNextBtn = document.getElementById('side-next-btn');

            const columnNames = ["position", "token", "explanation", "kl_divergence", "mse", "relative_rmse", "tuned_lens_top", "explanation_structured", "token_salience", "logit_lens_top", "layer"];
            let columnVisibility = {};
            let isTransposed = false;
            let allTranscripts = [];
            let currentTranscriptIndex = 0;
            let currentService = 'pantry'; // 'pantry' or 'jsonbin'
            let salienceColoringEnabled = false;
            let salienceMin = -0.1;
            let salienceMax = 0.3;

		// --- API & Sharing Logic ---
	    const updateServiceUI = (service) => {
	        currentService = service;
	        
	        pantryBtn.classList.toggle('active-service', service === 'pantry');
	        jsonbinBtn.classList.toggle('active-service', service === 'jsonbin');

	        if (service === 'pantry') {
	            apiKeyLabel.textContent = 'Pantry ID:';
	            apiKeyInput.placeholder = 'Paste your Pantry ID here';
	            apiKeyInput.value = localStorage.getItem('logViewerPantryId') || '88947592-e047-4e50-bfc7-d55c93fb6f35'; 

	            collectionIdLabel.textContent = 'Basket Name:';
	            collectionIdInput.placeholder = 'e.g., data-viewer-storage';
	            collectionIdInput.value = localStorage.getItem('logViewerPantryBasket') || 'data-viewer-storage';
	        } else { // jsonbin
	            apiKeyLabel.textContent = 'Your Public, Scoped API Key:';
	            apiKeyInput.placeholder = 'Paste your public API key here';
	            apiKeyInput.value = localStorage.getItem('logViewerJsonbinApiKey') || '$2a$10$cYXiC7n7tURzBeNd7E2yx.NsMNqmaYgWCoAYTmiFfGHjZKC54V.Sq';

	            collectionIdLabel.textContent = 'Your Public Collection ID:';
	            collectionIdInput.placeholder = 'Paste your public Collection ID here';
	            collectionIdInput.value = localStorage.getItem('logViewerJsonbinCollectionId') || '6867e9e58561e97a5031776b';
	        }
	    };
	    
	    const saveSettings = () => {
	        if (currentService === 'pantry') {
	            localStorage.setItem('logViewerPantryId', apiKeyInput.value);
	            localStorage.setItem('logViewerPantryBasket', collectionIdInput.value);
	        } else {
	            localStorage.setItem('logViewerJsonbinApiKey', apiKeyInput.value);
	            localStorage.setItem('logViewerJsonbinCollectionId', collectionIdInput.value);
	        }
	    };

        const setupServiceSwitcher = () => {
            pantryBtn.addEventListener('click', () => updateServiceUI('pantry'));
            jsonbinBtn.addEventListener('click', () => updateServiceUI('jsonbin'));
            
            apiKeyInput.addEventListener('change', saveSettings);
            collectionIdInput.addEventListener('change', saveSettings);

            const lastService = localStorage.getItem('logViewerService') || 'pantry';
            updateServiceUI(lastService);

            window.addEventListener('beforeunload', () => {
                localStorage.setItem('logViewerService', currentService);
            });
        };
	    
	    setupServiceSwitcher();
	    
	    const uploadToBin = async (content) => {
	        const apiKey = apiKeyInput.value;
	        const collectionId = collectionIdInput.value;
	    
	        if (!apiKey || !collectionId) {
	            alert(currentService === 'pantry'
	                ? 'Please provide both a Pantry ID and a Basket Name in the Settings section.'
	                : 'Please provide both a JSONBin.io API Key and a Collection ID in the Settings section.');
	            return null;
	        }
	    
	        uploadBtn.disabled = true;
	        uploadBtn.textContent = 'Uploading...';
	    
	        console.log('Using service:', currentService);
	        console.log('API Key/Pantry ID:', apiKey ? 'Present' : 'Missing');
	        console.log('Collection ID/Basket:', collectionId ? 'Present' : 'Missing');
	        console.log('Content length:', content ? content.length : 'No content');
	    
	        try {
	            if (currentService === 'pantry') {
	                // Generate a unique ID for this upload
	                const uniqueId = 'log-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
	    
	                const res = await fetch(`https://getpantry.cloud/apiv1/pantry/${apiKey}/basket/${collectionId}`, {
	                    method: 'PUT',
	                    headers: {
	                        'Content-Type': 'application/json'
	                    },
	                    body: JSON.stringify({
	                        [uniqueId]: {
	                            data: content,
	                            timestamp: new Date().toISOString()
	                        }
	                    })
	                });
	    
	                if (!res.ok) {
                        const errorText = await res.text();
                        
                        // Check if the basket doesn't exist
                        if (errorText.includes('does not exist')) {
                            console.log('Basket does not exist, creating new basket...');
                            
                            // Create new basket with POST
                            const createRes = await fetch(`https://getpantry.cloud/apiv1/pantry/${apiKey}/basket/${collectionId}`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    [uniqueId]: {
                                        data: content,
                                        timestamp: new Date().toISOString()
                                    }
                                })
                            });
                            
                            if (!createRes.ok) {
                                const createErrorText = await createRes.text();
                                throw new Error(`Failed to create basket: ${createRes.statusText}. Response: ${createErrorText}`);
                            }
                            
                            // Successfully created basket with data
                            return `${collectionId}/${uniqueId}`;
                        }
                        
	                    throw new Error(`Failed to upload: ${res.statusText}. Response: ${errorText}`);
	                }
	    
	                // Return the unique ID that can be used to retrieve this specific log
	                return `${collectionId}/${uniqueId}`;
	            } else {
	                // Original JSONBin code
	                const res = await fetch('https://api.jsonbin.io/v3/b', {
	                    method: 'POST',
	                    headers: {
	                        'Content-Type': 'application/json',
	                        'X-Access-Key': apiKey,
	                        'X-Bin-Name': 'LogViewer-Data-' + new Date().toISOString(),
	                        'X-Collection-Id': collectionId,
	                        'X-Bin-Private': 'false'
	                    },
	                    body: JSON.stringify({ data: content })
	                });
	    
	                if (!res.ok) {
	                    throw new Error(`Failed to upload: ${res.statusText}`);
	                }
	    
	                const result = await res.json();
	                return result.metadata.id;
	            }
	        } catch (error) {
	            console.error('Upload failed - Full error object:', error);
	            console.error('Error message:', error.message);
	            console.error('Error stack:', error.stack);
	            alert(currentService === 'pantry'
			    ? "Upload failed. Please check your Pantry ID, Basket Name, and network connection. Your basket may be full; please change the basket name in the settings to start filling a new one. ${error.message}"
			    : "Upload failed. Please check your API key, Collection ID, and network connection. Also we do not currently support jsons over 100kb ${error.message}");
	            return null;
	        } finally {
	            uploadBtn.disabled = false;
	            uploadBtn.textContent = 'Upload & Get Link';
	        }
	    };
	    
	    const fetchFromBin = async (binId) => {
            const isPantry = binId.includes('/');
            updateServiceUI(isPantry ? 'pantry' : 'jsonbin');

	        try {
	            if (isPantry) {
	                // binId format for Pantry: "basketName/uniqueId"
	                const [basketName, uniqueId] = binId.split('/');
                    // Use the ID from the input, which is now correctly set by updateServiceUI
	                const pantryId = apiKeyInput.value; 
	    
	                const res = await fetch(`https://getpantry.cloud/apiv1/pantry/${pantryId}/basket/${basketName}`);
	                if (!res.ok) {
	                    throw new Error('Failed to fetch basket');
	                }
	    
	                const result = await res.json();
	    
	                if (uniqueId && result[uniqueId]) {
	                    return result[uniqueId].data;
	                }
	    
	                // This part might be tricky if the basket is large.
                    // For now, assume we always get a unique ID.
	                return result; 
	            } else {
	                // Original JSONBin code
	                const res = await fetch(`https://api.jsonbin.io/v3/b/${binId}/latest`);
	                if (!res.ok) {
	                    throw new Error('Failed to fetch bin');
	                }
	                const result = await res.json();
	                return result.record.data;
	            }
	        } catch (error) {
	            console.error('Fetch failed:', error);
	            alert(`Could not load data for ${isPantry ? 'pantry item' : 'bin'} ID: ${binId}. The link may be invalid, the data expired, or the Pantry ID in settings is incorrect.`);
	            return null;
	        }
	    };

            const setDefaultVisibility = () => {
                const defaultVisibleCols = ['token', 'explanation', 'mse'];
                columnNames.forEach(colName => {
                    columnVisibility[colName] = defaultVisibleCols.includes(colName);
                });
            };
            setDefaultVisibility();
            
            const transformColumnData = (colData) => {
                const data = [];
                const keys = Object.keys(colData);
                if (keys.length === 0) return [];

                const numRows = Object.keys(colData[keys[0]]).length;

                for (let i = 0; i < numRows; i++) {
                    const row = {};
                    keys.forEach(key => {
                        if (colData[key] && colData[key][String(i)] !== undefined) {
                            row[key] = colData[key][String(i)];
                        }
                    });
                    data.push(row);
                }
                return data;
            };

            const parseText = (text) => {
                if (!text || text.trim() === '') return [];
                try {
                    const jsonBlocks = text.trim().replace(/}(?:\s|\n)*{/g, '}|||JSON_DELIMITER|||{').split('|||JSON_DELIMITER|||');
                    const transcripts = [];

                    for (const block of jsonBlocks) {
                        if (block.trim() === "") continue;
                        const parsed = JSON.parse(block);
                        
                        let dataPart = parsed;
                        let metadata = null;

                        // Check for new format with metadata
                        if (parsed && parsed.metadata && parsed.data) {
                            dataPart = parsed.data;
                            metadata = parsed.metadata;
                        }

                        let transcriptData;
                        if (dataPart && typeof dataPart === 'object' && !Array.isArray(dataPart) && dataPart.position) {
                            // Column-oriented data
                            transcriptData = transformColumnData(dataPart);
                        } else if (Array.isArray(dataPart)) {
                            // Row-oriented data
                            transcriptData = dataPart;
                        }

                        if (transcriptData && transcriptData.length > 0) {
                            transcriptData.forEach(row => {
                               if (!row.explanation && Array.isArray(row.explanation_structured)) {
                                   row.explanation = row.explanation_structured.join('');
                               }
                           });
                            transcripts.push({ data: transcriptData, metadata: metadata });
                       }
                    }
                    return transcripts;
                } catch (e) {
                    console.error("Invalid JSON input:", e);
                    alert("There was an error parsing the JSON data. Please check the console for details.");
                    return [];
                }
            };

            const formatNewlines = (str) => {
                if (typeof str !== 'string') return str;
                return str.replace(/\\n|\n/g, '↵ ');
            };
            
            const getSalienceColor = (value, min, max) => {
                if (typeof value !== 'number' || isNaN(value)) return 'transparent';

                // Clamp to range (-1 .. max)
                const v = Math.max(-1, Math.min(max, value));

                if (v >= 0) {
                    // Log-scaled red side (0 → white, max → red)
                    const beta = 50; // controls curvature
                    const norm = max > 0 ? Math.log10(1 + beta * v) / Math.log10(1 + beta * max) : 0;
                    const g = Math.round(255 * (1 - norm));
                    const b = g;
                    return `rgb(255,${g},${b})`;
                } else {
                    // Linear green side, -1 = full green, 0 = white
                    const norm = (-v) / 1; // since min fixed to -1
                    const r = Math.round(255 * (1 - norm));
                    const b = r;
                    return `rgb(${r},255,${b})`;
                }
            };
            const getTooltipTextColor = (salVal) => {
		return '#3E2723';
                // if (salVal >= -0.3 && salVal < 0) return '#3E2723';
                // if (Math.abs(salVal) < 0.05) return '#3E2723';
                // return '#FFFFFF';
            };

            const renderFullTextBox = (data) => {
                fullTextContainer.innerHTML = '';
                if (!data || data.length === 0) {
                    fullTextContainer.appendChild(fullTextPlaceholder);
                    return;
                }
                fullTextPlaceholder.classList.add('hidden');
                
                const salienceScores = data.flatMap(row => {
                    if (Array.isArray(row.token_salience)) {
                        return row.token_salience.filter(s => typeof s === 'number' && !isNaN(s));
                    } else if (typeof row.token_salience === 'number' && !isNaN(row.token_salience)) {
                        return [row.token_salience];
                    }
                    return [];
                });
                const minSalience = Math.min(...salienceScores, 0);
                const maxSalience = Math.max(...salienceScores, 0.1);

                data.forEach((row, rowIndex) => {
                    const tokenString = String(row.token || '');
                    const parts = tokenString.split(/\\n|\n/);
                    
                    // Track which salience index to use for multi-token entries
                    let salienceIndex = 0;

                    parts.forEach((part, index) => {
                        if (part === '' && index === parts.length - 1 && parts.length > 1) return;

                        const container = document.createElement('div');
                        container.className = 'token-box-container';

                        const tokenSpan = document.createElement('span');
                        tokenSpan.className = 'token-box';
                        
                        const textContent = (index < parts.length - 1) ? part + ' ↵' : part;
                        tokenSpan.textContent = textContent;

                        const tooltip = document.createElement('div');
                        tooltip.className = 'tooltip';
                        
                        // Build colour-coded explanation for tooltip
                        if (row.explanation_structured && Array.isArray(row.explanation_structured)) {
                            tooltip.innerHTML = '';
                            row.explanation_structured.forEach((tok, idx) => {
                                const span = document.createElement('span');
                                span.textContent = formatNewlines(tok) + ' ';
                                if (Array.isArray(row.token_salience) && idx < row.token_salience.length) {
                                    const sv = row.token_salience[idx];
                                    if (salienceColoringEnabled && typeof sv === 'number') {
                                        span.style.backgroundColor = getSalienceColor(sv, salienceMin, salienceMax);
                                        span.style.color = getTooltipTextColor(sv);
                                    }
                                    if (typeof sv === 'number') {
                                        span.title = `Decoded: ${tok}\nSalience: ${sv.toFixed(3)}\nMSE: ${row.mse?.toFixed ? row.mse.toFixed(3) : row.mse}`;
                                    }
                                }
                                tooltip.appendChild(span);
                            });
                        } else {
                            tooltip.textContent = formatNewlines(row.explanation || 'No explanation available.');
                        }
                        
                        container.appendChild(tokenSpan);
                        container.appendChild(tooltip);
                        fullTextContainer.appendChild(container);

                        if (index < parts.length - 1) {
                            fullTextContainer.appendChild(document.createElement('br'));
                        }
                    });
                });
            };

            const renderMetadata = (metadata) => {
                if (metadata && Object.keys(metadata).length > 0) {
                    metadataDisplay.classList.remove('hidden');
                    let html = '<ul class="list-disc list-inside space-y-1">';
                    if (metadata.model_name) {
                        html += `<li><strong>Decoder/Encoder Model:</strong> <span class="font-semibold">${metadata.model_name}</span></li>`;
                    }
                    if (metadata.orig_model_name) {
                        html += `<li><strong>Subject Model:</strong> <span class="font-semibold">${metadata.orig_model_name}</span></li>`;
                    }
                    if (metadata.checkpoint_path) {
                        html += `<li><strong>Checkpoint:</strong> <span class="font-mono text-xs">${metadata.checkpoint_path}</span></li>`;
                    }
                    html += '</ul>';
                    metadataDisplay.innerHTML = html;
                } else {
                    metadataDisplay.classList.add('hidden');
                    metadataDisplay.innerHTML = '';
                }
            };

            const renderColumnToggles = () => {
                columnToggleContainer.innerHTML = '';
                if (isTransposed) return;

                const toggleButton = document.createElement('button');
                toggleButton.className = "px-4 py-2 text-sm secondary-btn font-semibold rounded-lg shadow-sm transition-all duration-200 transform hover:scale-105 flex items-center gap-2";
                toggleButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18"/></svg> Toggle Columns`;
                
                // Remove any previous dropdowns to avoid duplicates
                document.querySelectorAll('#column-toggle-dropdown').forEach(el=>el.remove());

                const dropdown = document.createElement('div');
                dropdown.id = 'column-toggle-dropdown';
                dropdown.className = "absolute right-0 mt-2 w-56 origin-top-right bg-white rounded-md shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none hidden z-20 border border-slate-200";
                
                let checkboxesHTML = '';
                columnNames.forEach(colName => {
                    checkboxesHTML += `
                        <label class="flex items-center px-4 py-2 text-sm text-slate-700 hover:bg-slate-50 cursor-pointer">
                            <input type="checkbox" data-column="${colName}" class="h-4 w-4 rounded border-slate-300 text-orange-600 focus:ring-orange-500" ${columnVisibility[colName] ? 'checked' : ''}>
                            <span class="ml-3 select-none">${colName.replace(/_/g, ' ')}</span>
                        </label>
                    `;
                });
                dropdown.innerHTML = checkboxesHTML;

                toggleButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    dropdown.classList.toggle('hidden');
                });

                dropdown.addEventListener('change', (e) => {
                    if (e.target.type === 'checkbox') {
                        const columnName = e.target.dataset.column;
                        columnVisibility[columnName] = e.target.checked;
                        updateColumnVisibility();
                    }
                });
                
                columnToggleContainer.appendChild(toggleButton);
                document.body.appendChild(dropdown);
                
                toggleButton.addEventListener('click', () => {
                    const rect = toggleButton.getBoundingClientRect();
                    dropdown.style.left = `${rect.left + window.scrollX}px`;
                    dropdown.style.top = `${rect.bottom + window.scrollY + 5}px`;
                });
            };
            
            const updateColumnVisibility = () => {
                for (const columnName in columnVisibility) {
                    const visible = columnVisibility[columnName];
                    document.querySelectorAll(`[data-column-name="${columnName}"]`).forEach(cell => {
                        cell.style.display = visible ? '' : 'none';
                    });
                }
            };

            const applySpacing = () => {
                const spacing = lineSpacingSlider.value;
                if (isTransposed) {
                    document.querySelectorAll('.explanation-word').forEach(word => {
                        word.style.paddingBottom = `${spacing}px`;
                    });
                    const container = transposedView.querySelector('.flex-row');
                     if (container) {
                        container.style.rowGap = '0px';
                    }
                } else {
                    document.querySelectorAll('#table-body td').forEach(td => {
                        td.style.paddingTop = `${spacing}px`;
                        td.style.paddingBottom = `${spacing}px`;
                    });
                }
            };

            const renderTable = (data) => {
                tableHead.innerHTML = '';
                tableBody.innerHTML = '';

                const headerRow = document.createElement('tr');
                headerRow.className = "bg-[#EFEBE9]";
                columnNames.forEach((colName, index) => {
                    const th = document.createElement('th');
                    th.className = "px-2 py-2 text-left text-sm font-semibold text-[#5D4037] uppercase tracking-wider";
                    th.dataset.columnName = colName;
                    th.dataset.columnIndex = index;
                    th.textContent = colName.replace(/_/g, ' ');
                    
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'resize-handle';
                    th.appendChild(resizeHandle);

                    headerRow.appendChild(th);
                });
                tableHead.appendChild(headerRow);

                const klValues = data.map(row => parseFloat(row.kl_divergence)).filter(v => !isNaN(v));
                const maxKl = Math.max(...klValues, 0);

                data.forEach((row) => {
                    const tr = document.createElement('tr');
                    tr.className = 'hover:bg-[#EFEBE9]/80 border-b border-[#EFEBE9]';
                    columnNames.forEach(colName => {
                        const td = document.createElement('td');
                        td.className = "px-2 py-2 align-top font-mono text-sm text-[#5D4037]";
                        td.dataset.columnName = colName;
                        td.title = `Click to copy`;
                        let value = row[colName] || '';
                        if (['kl_divergence', 'mse', 'relative_rmse'].includes(colName)) {
                            const num = parseFloat(value);
                            value = isNaN(num) ? 'N/A' : num.toFixed(6);
                        }
                        if (colName === 'token_salience') {
                            if (Array.isArray(value)) {
                                value = value.map(v => typeof v === 'number' ? v.toPrecision(3) : v).join(', ');
                            } else if (typeof value === 'number') {
                                value = value.toPrecision(3);
                            }
                        }
                        td.textContent = formatNewlines(String(value));
                        
                        if (colName === 'explanation_structured' && Array.isArray(row.explanation_structured)) {
                            td.textContent = '';
                            row.explanation_structured.forEach((w, idx) => {
                                const span = document.createElement('span');
                                span.className = 'explanation-word';
                                span.textContent = formatNewlines(w) + ' ';

                                // colouring + tooltip
                                if (Array.isArray(row.token_salience) && idx < row.token_salience.length) {
                                    const sv = row.token_salience[idx];
                                    if (salienceColoringEnabled && typeof sv === 'number') {
                                        span.style.backgroundColor = getSalienceColor(sv, salienceMin, salienceMax);
                                        span.style.color = getTooltipTextColor(sv);
                                    }
                                    if (typeof sv === 'number') {
                                        span.title = `Decoded: ${w}\nSalience: ${sv.toFixed(3)}\nMSE: ${row.mse?.toFixed ? row.mse.toFixed(3) : row.mse}`;
                                    }
                                }
                                td.appendChild(span);
                            });
                        } else if (colName === 'explanation' && Array.isArray(row.explanation_structured)) {
                            td.textContent = '';
                            row.explanation_structured.forEach((w, idx) => {
                                const span = document.createElement('span');
                                span.className = 'explanation-word';
                                span.textContent = formatNewlines(w) + ' ';

                                if (Array.isArray(row.token_salience) && idx < row.token_salience.length) {
                                    const sv = row.token_salience[idx];
                                    if (salienceColoringEnabled && typeof sv === 'number') {
                                        span.style.backgroundColor = getSalienceColor(sv, salienceMin, salienceMax);
                                        span.style.color = getTooltipTextColor(sv);
                                    }
                                    if (typeof sv === 'number') {
                                        span.title = `Decoded: ${w}\nSalience: ${sv.toFixed(3)}\nMSE: ${row.mse?.toFixed ? row.mse.toFixed(3) : row.mse}`;
                                    }
                                }
                                td.appendChild(span);
                            });
                        } else if (['explanation', 'tuned_lens_top', 'logit_lens_top'].includes(colName)) {
                            td.className = "px-2 py-2 align-top font-sans text-sm text-[#6D4C41]";
                            td.style.whiteSpace = 'nowrap';
                        }
                        if (colName === 'token') { td.className = "px-2 py-2 align-top font-mono text-sm font-semibold text-[#BF360C]"; }
                        if (colName === 'position') { td.className = "px-2 py-2 align-top font-mono text-sm text-slate-400"; }
                        if (colName === 'kl_divergence') {
                            const klValue = parseFloat(row.kl_divergence);
                            const klIntensity = isNaN(klValue) || maxKl === 0 ? 0 : Math.min(klValue / (maxKl * 0.8), 1);
                            const r = 230 - (50 * klIntensity); 
                            const g = 81 - (20 * klIntensity); 
                            const b = 0;
                            td.style.color = `rgb(${r}, ${g}, ${b})`;
                            td.style.fontWeight = '500';
                        }
                        tr.appendChild(td);
                    });
                    tableBody.appendChild(tr);
                });
                updateColumnVisibility();
                applySpacing();
            };

            const renderTransposedView = (data) => {
                transposedView.innerHTML = '';
                const container = document.createElement('div');
                container.className = 'flex flex-row flex-wrap gap-x-2';
                const colWidth = parseInt(colWidthSlider.value, 10);

                const salienceScores = data.flatMap(row => {
                    if (Array.isArray(row.token_salience)) {
                        return row.token_salience.filter(s => typeof s === 'number' && !isNaN(s));
                    } else if (typeof row.token_salience === 'number' && !isNaN(row.token_salience)) {
                        return [row.token_salience];
                    }
                    return [];
                });
                const minSalience = Math.min(...salienceScores, 0);
                const maxSalience = Math.max(...salienceScores, 0.1);

                data.forEach((row, rowIndex) => {
                    const colDiv = document.createElement('div');
                    colDiv.className = 'flex flex-col items-start font-mono text-sm transpose-col';
                    colDiv.style.width = `${colWidth}px`;
                    
                    const tokenWrapper = document.createElement('div');
                    tokenWrapper.className = 'rotated-token-wrapper';

                    const tokenDiv = document.createElement('div');
                    tokenDiv.className = 'font-semibold text-base rotated-token text-[#BF360C]';
                    tokenDiv.textContent = formatNewlines(row.token);
                    tokenDiv.title = `Token: ${formatNewlines(row.token)}\nMSE: ${Number(row.mse).toFixed(3)}`;
                    
                    tokenWrapper.appendChild(tokenDiv);
                    colDiv.appendChild(tokenWrapper);
                    
                    let explanationWords = [];
                    if (row.explanation_structured && Array.isArray(row.explanation_structured)) {
                        explanationWords = row.explanation_structured;
                    } else if(row.explanation) {
                         explanationWords = formatNewlines(row.explanation).split(/[\s↵]+/);
                    }

                    explanationWords.forEach((word, wordIndex) => {
                        const wordDiv = document.createElement('div');
                        wordDiv.className = 'text-[#6D4C41] font-sans w-full text-left explanation-word';
                        wordDiv.textContent = formatNewlines(word);
                        
                        // Apply salience coloring to decoded tokens
                        if (salienceColoringEnabled && Array.isArray(row.token_salience) && wordIndex < row.token_salience.length) {
                            const salienceValue = row.token_salience[wordIndex];
                            if (typeof salienceValue === 'number' && !isNaN(salienceValue)) {
                                wordDiv.style.backgroundColor = getSalienceColor(salienceValue, minSalience, maxSalience);
                                wordDiv.style.padding = '2px 4px';
                                wordDiv.style.borderRadius = '2px';
                                wordDiv.style.margin = '1px 0';
                            }
                        }
                        
                        // Add tooltip with salience info
                        if (Array.isArray(row.token_salience) && wordIndex < row.token_salience.length) {
                            const salienceValue = row.token_salience[wordIndex];
                            if (typeof salienceValue === 'number' && !isNaN(salienceValue)) {
                                wordDiv.title = `Decoded: ${word}\nSalience: ${salienceValue.toFixed(3)}\nMSE: ${row.mse?.toFixed ? row.mse.toFixed(3) : row.mse}`;
                            }
                        }
                        
                        colDiv.appendChild(wordDiv);
                    });

                    container.appendChild(colDiv);
                });
                transposedView.appendChild(container);
                applySpacing();
            };
            
            const render = () => {
                const currentItem = allTranscripts[currentTranscriptIndex];
                
                if (!currentItem || allTranscripts.length === 0) {
                    outputPlaceholder.classList.remove('hidden');
                    outputTable.classList.add('hidden');
                    transposedView.classList.add('hidden');
                    fullTextContainer.classList.add('hidden');
                    navigationContainer.classList.add('hidden');
                    displayControls.classList.add('hidden');
                    controlsSeparator.classList.add('hidden');
                    metadataDisplay.classList.add('hidden');
                    bottomNavigationContainer.classList.add('hidden');
                    sidePrevBtn.classList.add('hidden');
                    sideNextBtn.classList.add('hidden');
                    return;
                }
                
                const currentTranscript = currentItem.data;

                outputPlaceholder.classList.add('hidden');
                fullTextContainer.classList.remove('hidden');
                displayControls.style.display = 'flex';
                controlsSeparator.classList.remove('hidden');
                
                renderMetadata(currentItem.metadata);
                renderColumnToggles();
                renderFullTextBox(currentTranscript);

                if (isTransposed) {
                    outputTable.classList.add('hidden');
                    colWidthControl.classList.remove('hidden');
                    transposedView.classList.remove('hidden');
                    renderTransposedView(currentTranscript);
                } else {
                    outputTable.classList.remove('hidden');
                    colWidthControl.classList.add('hidden');
                    transposedView.classList.add('hidden');
                    tableHead.classList.remove('hidden');
                    renderTable(currentTranscript);
                }

                if (allTranscripts.length > 1) {
                    navigationContainer.classList.remove('hidden');
                    navCounter.textContent = `${currentTranscriptIndex + 1} / ${allTranscripts.length}`;
                    prevBtn.disabled = currentTranscriptIndex === 0;
                    nextBtn.disabled = currentTranscriptIndex === allTranscripts.length - 1;

                    bottomNavigationContainer.classList.remove('hidden');
                    bottomNavCounter.textContent = `${currentTranscriptIndex + 1} / ${allTranscripts.length}`;
                    bottomPrevBtn.disabled = currentTranscriptIndex === 0;
                    bottomNextBtn.disabled = currentTranscriptIndex === allTranscripts.length - 1;
                    
                    if (isTransposed) {
                        sidePrevBtn.classList.add('hidden');
                        sideNextBtn.classList.add('hidden');
                    } else {
                        sidePrevBtn.classList.remove('hidden');
                        sideNextBtn.classList.remove('hidden');
                        sidePrevBtn.style.visibility = (currentTranscriptIndex === 0) ? 'hidden' : 'visible';
                        sideNextBtn.style.visibility = (currentTranscriptIndex === allTranscripts.length - 1) ? 'hidden' : 'visible';
                    }

                } else {
                    navigationContainer.classList.add('hidden');
                    bottomNavigationContainer.classList.add('hidden');
                    sidePrevBtn.classList.add('hidden');
                    sideNextBtn.classList.add('hidden');
                }
            };

            const processData = (text) => {
                allTranscripts = parseText(text);
                currentTranscriptIndex = 0;
                
                // Default salience toggle to true if data is present
                const hasSalienceData = allTranscripts.some(t => t.data.some(r => r.token_salience !== undefined));
                salienceColoringEnabled = hasSalienceData;
                salienceToggle.checked = hasSalienceData;
                if (hasSalienceData) {
                    updateColourbar();
                }
                
                render();
            };

            parseBtn.addEventListener('click', () => {
                uploadBtn.disabled = textInput.value.trim() === '';
                processData(textInput.value)
            });
            
            uploadBtn.addEventListener('click', async () => {
                const binId = await uploadToBin(textInput.value);
                if (binId) {
                    const url = new URL(window.location);
                    url.search = '';
                    url.searchParams.set('bin', binId);
                    window.history.pushState({}, '', url);
                    alert(`Link created! The URL has been updated. You can now copy it from your address bar.`);
                }
            });

            transposeBtn.addEventListener('click', () => {
                isTransposed = !isTransposed;
                document.querySelectorAll('#column-toggle-dropdown').forEach(d=>d.classList.add('hidden'));
                render();
            });
            
            salienceToggle.addEventListener('change', () => {
                salienceColoringEnabled = salienceToggle.checked;
                updateColourbar();
                render();
            });

            bottomPrevBtn.addEventListener('click', () => prevBtn.click());
            bottomNextBtn.addEventListener('click', () => nextBtn.click());
            sidePrevBtn.addEventListener('click', () => prevBtn.click());
            sideNextBtn.addEventListener('click', () => nextBtn.click());

            prevBtn.addEventListener('click', () => {
                if (currentTranscriptIndex > 0) {
                    currentTranscriptIndex--;
                    render();
                }
            });
            nextBtn.addEventListener('click', () => {
                if (currentTranscriptIndex < allTranscripts.length - 1) {
                    currentTranscriptIndex++;
                    render();
                }
            });

            lineSpacingSlider.addEventListener('input', applySpacing);
            colWidthSlider.addEventListener('input', (e) => {
                const newWidth = e.target.value;
                document.querySelectorAll('.transpose-col').forEach(col => {
                    col.style.width = `${newWidth}px`;
                });
            });

            fileUpload.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        const fileContent = e.target.result;
                        textInput.value = fileContent;
                        uploadBtn.disabled = textInput.value.trim() === '';
                        processData(fileContent);
                        const binId = await uploadToBin(fileContent);
                         if (binId) {
                            const url = new URL(window.location);
                            url.search = '';
                            url.searchParams.set('bin', binId);
                            window.history.pushState({}, '', url);
                            alert(`File uploaded and link created! The URL has been updated.`);
                        }
                    };
                    reader.readAsText(file);
                }
            });

            textInput.addEventListener('input', () => {
                uploadBtn.disabled = textInput.value.trim() === '';
            });
            
            document.body.addEventListener('click', (e) => {
                const target = e.target;
                if (target.tagName === 'TD' && target.title === 'Click to copy') {
                     const textToCopy = target.textContent;
                     const textArea = document.createElement("textarea");
                     textArea.value = textToCopy;
                     document.body.appendChild(textArea);
                     textArea.select();
                     try {
                         document.execCommand('copy');
                         showCopyFeedback(target);
                     } catch (err) {
                         console.error('Failed to copy text: ', err);
                     }
                     document.body.removeChild(textArea);
                }
                
                const dropdown = document.querySelector('body > div.absolute');
                if (dropdown && !dropdown.classList.contains('hidden') && !e.target.closest('#column-toggle-container')) {
                    dropdown.classList.add('hidden');
                }
            });
            
            (async () => {
                const urlParams = new URLSearchParams(window.location.search);
                const binId = urlParams.get('bin');

                if (binId) {
                    const content = await fetchFromBin(binId);
                    if (content) {
                        textInput.value = content;
                        uploadBtn.disabled = textInput.value.trim() === '';
                        processData(content);
                    }
                } else {
                    processData('');
                }
            })();

            // Helper to compute trimmed salience range (5–95 percentile)
            const computeSalienceRange = (rows) => {
                const raw = rows.flatMap(r => {
                    if (Array.isArray(r.token_salience)) return r.token_salience;
                    if (typeof r.token_salience === 'number') return [r.token_salience];
                    return [];
                }).filter(v => typeof v === 'number' && !isNaN(v));
                if (raw.length === 0) return { min:-0.1, max:0.1 };
                const sorted = [...raw].sort((a,b)=>a-b);
                const low = sorted[Math.floor(sorted.length*0.05)];
                const high = sorted[Math.floor(sorted.length*0.95)];
                // Ensure min does not exceed -0.05 and include -1 bound for colour mapping
                return { min: Math.min(-0.05, low, -1), max: high };
            };

            // Update the visible colourbar according to current range
            const updateColourbar = () => {
                if (!salienceColoringEnabled) {
                    salienceColorbar.classList.add('hidden');
                    salienceDefinition.classList.add('hidden');
                    return;
                }
                salienceColorbar.classList.remove('hidden');
                salienceDefinition.classList.remove('hidden');
                salienceColorbar.style.background = 'linear-gradient(to right, rgb(0,200,0) 0%, #ffffff 50%, rgb(255,0,0) 100%)';
            };
        });
    </script>
</body>
</html>
